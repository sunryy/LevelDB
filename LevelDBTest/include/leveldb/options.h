#pragma once
#include <stddef.h>
namespace leveldb{

	class Cache;
	class Comparator;
	class Env;
	class Logger;
	class Snapshot;

	//DB contents ars stored in a set of blocks, each of which holds a 
	//sequence of key, value pairs. Each block may be compressed before
	//being stored in a file. The following enum describes which 
	//compression method (if any) is used to compress a block.

	enum CompressionType
	{
		//NOTE: do not change the values of existing entries, as these are
		//part of the persistent format on disk.
		kNoCompression	=0x0,
		kSnappyCompression	=0x1
	};

	//Options to control the behavior of a database(passed to DB::Open)
	struct Options 
	{
		//------------------
		//Parameters that affect behavior

		//Comparator used to define the order of keys in the table.
		//Default: a comparator that uses lexicographic byte-wise ordering
		//
		//REQUIRES: The client must ensure that the comparator supplied
		//here has the same name and orders keys *exactly* the same as the
		//comparator provided to previous open calls on the same DB.
		const Comparator* comparator;

		//If true, the database will be created if it is missing.
		//Default: false
		bool create_if_missing;

		//If true,an error is raised if the database already exists.
		//Default:false
		bool error_if_exists;

		bool paranoid_checks;

		//Use the specified object to interact with the environment,
		//e.g. to read/write files, schedule background work, etc.
		//Default: Env::Default()
		Env* env;

		//Any internal progress/error information generated by the db will be written
		//to info_log if it is non-NULL, or to a file stored in the same directory as the
		//DB contents if info_log is NULL.
		Logger* info_log;

		//Parameters that affect performance
		//Amount of data to build up in memory (backed by an unsorted log on disk)
		//before converting to a sorted on-disk file.
		size_t write_buffer_size;

		//Number of open fiels that can be used by the DB.
		int max_open_files;

		//Control over blocks (user data is stored in a set of blocks, and a block
		//is the unit of reading from disk).
		Cache* block_cache;

		//Approximate size of user data packed per block.
		size_t block_size;

		//Number of keys between restart points for delta encoding of keys.
		int block_restart_interval;

		//Compress blocks using the specified compression algorithm.
		CompressionType compression;

		//Create an Options object with default values for all fields.
		Options();
	};

	//Options that control read operations
	struct ReadOptions 
	{
		//If true, all data read from underlying storage will be
		//verified against corresponding checksums.
		bool verify_checksums;

		//Should the data read for this iteration be cached in memory?
		//Callers may wish to set this field to false for bulk scans.
		bool fill_cache;

		//If "snapshot" is non-NULL, read as of the supplied snapshot
		//(which must belong to the DB that is being read and which must 
		//not have been released).
		const Snapshot* snapshot;

		ReadOptions()
			:verify_checksums(false),
			fill_cache(true),
			snapshot(NULL)
		{

		}
	};

	//Options that control write operations
	struct WriteOptions 
	{
		//If true, the write will be flushed from the operating system buffer cache(
		// by calling writableFile::Sync()) before the write is considered complete.If this
		//flag is true, writes will be slower.
		bool sync;
		WriteOptions()
			:sync(false){

		}
	};

}